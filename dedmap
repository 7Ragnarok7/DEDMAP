#!/usr/bin/python

#IMPORTING REQUIRED LIBRARIES
import os
import socket
from datetime import datetime
from time import time
from funcy import flatten
from numpy import array
from colorama import init, Fore
import subprocess
import sys
import getopt
import logging as log

try:
	#SETTING UP A COLOR SCHEME FOR BETTER VISUALISATION
	init()
	BLUE = Fore.BLUE
	RED = Fore.RED
	GREEN = Fore.GREEN
	RESET = Fore.RESET
	GRAY = Fore.LIGHTBLACK_EX
	
	#SETTING UP A LOGGING SYSTEM
	log.basicConfig(level = log.INFO, format = '  %(message)s', handlers = [log.FileHandler('temp.log'), log.StreamHandler()])
	
	#GRAPHICS/TEXT ART
	subprocess.call('echo && pyfiglet -c RED dedmap -f Bloody', shell = True)

	#INITIAL MESSAGE
	log.info("\n{}Starting DEDMAP at {} ( https://7ragnarok7.github.io/DEDMAP ) .....{}".format(BLUE, datetime.now().strftime('"%B %d, %Y" %H:%M:%S'), RESET))
	with open("temp.log", "a") as file: file.write("\nCommand used: {}\n".format(" ".join(sys.argv)))
	
	#FUNCTION TO WRITE OUTPUT TO A FILE
	def write():
		if "--write" in options: 
			print("\nWriting the output to {},\n".format(options["--write"]))
			subprocess.call("cat temp.log >> {} && rm temp.log".format(options["--write"]), shell = True)
		else: subprocess.call("rm temp.log", shell = True)

	#DEFINED A HELP FUNCTION TO OUTPUT USAGE INSTRUCTIONS
	def help(): print("""
DEDMAP ( https://7ragnarok7.github.io/DEDMAP )

Usage: dedmap [--option(s)] [target(s)]

By default a tcp scan will be performed if no options are provided.
-t option must be exclusively used if any other option is used like -v
By default the well-known top 1024 ports will be scanned if no ports are specified.
Long Options (--<options>) have more priority.

Options:
-h, --help              show this help message and exit
-v, --verbose           run in verbose mode
-d, --dns               performs a dns lookup
-r, --rdns				performs a reverse dns lookup
-p, --port<port(s)>     only scan specified port(s)
                        Ex: -p 21; -p 21,22,23;
                        -p user; (scan user ports from 1024 to 49151)
                        -p private; (scan private ports from 49152 to 65535)
                        -p all; (scan all ports from 0 to 65535)
-t, --tcp               perform a tcp scan (default scan if NO OPTIONS ARE specified)
-u, --udp               perform a udp scan (NOT WORKING PRESENTLY!!!!)
-s, --sweep             perform a sweep scan
-m, --mode<wan/lan>     select the mode for sweep scan (default = wan)
                        Select lan mode(turbo mode) for better scanning speeds (upto 10x)
                        It is recommended to use the turbo mode only on a lan network
                        as it might result loss of accuracy in wan networks
                        Ex: -sm lan; -sm wan;
-w, --write<filename>   writes the results in a file
                        Ex: -w report.txt

Examples:               dedmap 1.1.1.1
                        dedmap localhost
                        dedmap -d google.com yahoo.com facebook.com localhost
                        dedmap google.com
                        dedmap google.com yahoo.com
                        dedmap 1.1.1.1 2.2.2.2 3.3.3.3
                        dedmap 1.1.1.1-100 google.com (Perform a tcp scan on all the hosts without pinging to bypass firewall icmp block)
                        dedmap -p 20 1.1.1.1
                        dedmap -p 20,21,22 1.1.1.1
                        dedmap -sm lan -p 21 192.168.1.1-255 (Perform a tcp port scan in lan mode on all the live hosts)
                        dedmap -s 1.1.1.1-255
                        dedmap -sr 1.1.1.1-255 (Perform a dns lookup on all the live targets in the network)
                        dedmap -st 1.1.1.0-255 (To scan only the hosts which are alive in the network)
                        dedmap -w report.txt 127.0.0.1
""")



	#DEFINED A FUNCTION FOR DEBUGGING
	def debug():
		print(targets)
		print(options)
		print(TARGET_IP)
		print(TARGET_LEN)
		print(OPTION_LEN)
		print(live_targets)
	
	#DESIGNED A FUNTION TO GIVE PRIORITY TO LONG-FORMAT ARGUMENTS
	def priority():
		for item in POSSIBLE_OPTIONS:
			if item in options and POSSIBLE_OPTIONS[item] in options: del(options[item])
			elif item in options: options[POSSIBLE_OPTIONS[item]] = options.pop(item)
		
	#DESIGNED AN ALGORITHM TO CONVERT IP-RANGE TO A LIST OF IP'S
	def convert(seperated, index):
		new_targets = []
		octets = seperated[0].split(".")
		new = [i for i in range(int(octets[3]), int(seperated[1]) + 1)]
		for i in new: new_targets.append(".".join([octets[0], octets[1], octets[2], str(i)]))	 
		targets[index] = new_targets
	
	#TCP / UDP SCANNER ***************
	def tcp_udp(mode, start, end):
		log.info("\nPerforming a {} scan.....\n".format(mode))
		if "--sweep" in options:
			log.info("\nFound {} live targets!\nScanning only the live hosts as a sweep scan was performed before.".format(len(live_targets)))
			for ip in live_targets:
				log.info("---------------- Scanning {} ---------------\n".format(ip))
				port_count = 0
				if len(ports):
					for p in ports:
						if mode == "tcp": sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
						elif mode == "udp": sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
						else:
							write()
							sys.exit("\nInvalid mode specified!\n")
						sock.settimeout(0.1)
						result = sock.connect_ex((ip, port))
						if not result:
							port_count += 1
							log.info("  PORT {}  -->   OPEN   ".format(p))
						elif result and "--verbose" in options: print("  PORT {}  -->   CLOSED   ".format(p))
						sock.close()
					log.info("\nFound {} out of {} ports open for the host: {}\n".format(port_count, len(ports), ip))
				else:
					for p in range(start, end):
						if mode == "tcp": sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
						elif mode == "udp": sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
						else:
							write()
							sys.exit("\nInvalid mode specified!\n")
						sock.settimeout(0.1)
						result = sock.connect_ex((ip, p))
						if not result:
							port_count +=1
							log.info("  PORT {}  -->   OPEN   ".format(p))
						elif result and "--verbose" in options: print("  PORT {}  -->   CLOSED   ".format(p))
						sock.close()
					log.info("\nFound {} out of {} ports open for the host: {}\n".format(port_count, end - start, ip))		
		else:
			log.info("\nScanning all the {} targets as no sweep scan was performed.\n".format(len(TARGET_IP)))
			for ip in TARGET_IP:
				if "--verbose" in options: print("---------------- Scanning {} ---------------\n".format(ip))
				port_count = 0
				if len(ports):
					for p in ports:
						if mode == "tcp": sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
						elif mode == "udp": sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
						else:
							write()
							sys.exit("\nInvalid mode specified!\n")
						sock.settimeout(0.1)	
						result = sock.connect_ex((ip, p))
						if not result:
							port_count += 1
							log.info("  PORT {}  -->   OPEN   ".format(p))
						elif reusult and "--verbose" in options: print("  PORT {}  -->   CLOSED   ".format(p))
						sock.close()
					if not port_count: log.info("\nFound {} out of {} ports open for the host: {}\n".format(port_count, len(ports), ip))
				else:
					for p in range(start, end):
						if mode == "tcp": sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
						elif mode == "udp": sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
						else:
							write()
							sys.exit("\nInvalid mode specified!\n")
						sock.settimeout(0.1)
						result = sock.connect_ex((ip, p))
						if not result:
							port_count +=1
							log.info("  PORT {}  -->   OPEN   ".format(p))
						elif result and "--verbose" in options: print("  PORT {}  -->   CLOSED   ".format(p))
						sock.close()
					if not port_count: log.info("\nFound {} out of {} ports open for the host: {}\n".format(port_count, end - start, ip))
				
	
	#MAIN SCANNING FUNCTION ********
	def scan():
		#DNS LOOKUP
		if "--dns" in options: log.info("\nPerforming a DNS lookup.....\n\n{}\n".format(array(list(zip(targets, TARGET_IP)))))
		
		#SWEEP SCAN
		if "--sweep" in options:
			log.info("\nPerforming a sweep scan.....\n")
			for ip in TARGET_IP:
				if "--verbose" in options: print("Scanning {} .....".format(ip))
				if "--mode" not in options or options["--mode"] == "wan": response = os.popen("ping -b -c 1 -w 1 {}".format(ip))
				else: response = os.popen("ping -b -c 1 -W 0.1 {}".format(ip))
				if "ttl" in response.readlines()[1].lower():
					log.info("{} --> Live".format(ip))
					live_targets.append(ip) #STORING ALL THE LIVE TARGETS
			log.info("\n{} hosts alive out of {}\n".format(len(live_targets), TARGET_LEN))
		
		#REVERSE-DNS LOOKUP
		if "--rdns" in options:
			log.info("\nPerforming a REVERSE-DNS lookup.....\n")
			if "--sweep" in options: hostnames = list(map(socket.getfqdn, live_targets))
			else: hostnames = list(map(socket.getfqdn, TARGET_IP))
			log.info(array(list(zip(hostnames, live_targets))))
			
		#TCP/UDP SCAN
		if "--tcp" in options or OPTION_LEN == 0: #MUST SPECIFY -t OPTION IN ANY OTHER OPTION IS GIVEN (EVEN -v)
			if "--port" not in options: tcp_udp("tcp", 0, 1024)
			elif options["--port"] == "user": tcp_udp("tcp", 1024, 49152)
			elif options["--port"] == "private": tcp_udp("tcp", 49152, 65536)
			elif options["--port"] == "all": tcp_udp("tcp", 0, 65536)
			
		if "--udp" in options:
			if "--port" not in options: tcp_udp("udp", 0, 1024)
			elif options["--port"] == "user": tcp_udp("udp", 1024, 49152)
			elif options["--port"] == "private": tcp_udp("udp", 49152, 65536)
			elif options["--port"] == "all": tcp_udp("udp", 0, 65536)
			else: print("Invalid port option specified!")
		
	#GETTING HOSTNAMES, IPS AND SCANNING PARAMETERS FORM SHELL ARGUMENTS
	options, targets = getopt.getopt(sys.argv[1:], 'sdrtuhvp:w:m:', ['sweep', 'dns', 'rdns', 'tcp', 'udp', 'help', 'verbose', 'port=', 'write=', 'mode='])
	
	#CHECKING WHETHER THERE IS AN IP-RANGE OR NOT 
	for item in targets:
		if "-" in item:
			new = item.split("-")
			if "".join(new[0].split(".")).isdigit(): convert(new, targets.index(item))

	#VARIABLES
	targets = list(flatten(targets)) #CONVERTING NESTED LISTS RETURNED FROM CONVERT() TO NORMAL LISTS
	options = dict(options) #CONVERTING THE OPTIONS INTO A DICTIONARY FOR BETTER ADDRESSING
	ports = []
	live_targets = []

	#CONSTANTS
	POSSIBLE_OPTIONS = {"-s":"--sweep", "-m":"--mode", "-d":"--dns", "-r":"--rdns", "-t":"--tcp", "-u":"--udp", "-h":"--help", "-v":"--verbose", "-p":"--port", "-w":"--write"}
	TARGET_IP = list(map(socket.gethostbyname, targets)) #GETTING IPS FROM HOSTNAMES/DOMAIN NAMES
	TARGET_LEN = len(TARGET_IP)
	OPTION_LEN = len(options)
	
	#GIVING PRIORITY TO LONG-FORMAT ARGUMENTS
	priority()
	
	#GETTING SPECIFIC PORTS
	if "--port" in options: 
		if "," in options["--port"] : ports = options["--port"].split(",")
		elif options["--port"].isdigit(): ports.append(options["--port"])
	ports = [int(i) for i in ports]

	################### MAIN ############################ *********

	#HELP
	if "--help" in options:
		write()
		sys.exit(help())

	#CHECKING FOR EMPTY HOSTS
	if not targets:
		write()
		sys.exit("\nNo targets specified!\n\nUsage: dedmap [--option(s)] [target(s)]\n\n{}\n\nUse dedmap -h or --help to get a detailed usage instruction.\n".format(array(list(zip(list(POSSIBLE_OPTIONS), list(POSSIBLE_OPTIONS.values()))))))

	#RECORDING THE STARTING TIME TO CALCULATE TOTAL SCANNING TIME
	STARTING_TIME = time()
	
	#STARTING THE SCAN *********
	scan()
	
	#TOTAL COMPLETION TIME
	log.info("\nScan completed in: {} seconds.".format(round(time() - STARTING_TIME, 2)))
	
	#DEBUGGING ---- COMMENT OR UNCOMMENT TO TURN OFF OR ON. MOVE THIS PART OF CODE UP OR BELOW SOME OTHER CODE TO PERFORM EXECUTION ORDER SPECIFIC DEBUGGING
	#debug()

	#REPORTING
	log.info("\nReport BUGS at ( https://github.com/7Ragnarok7/DEDMAP/issues )\n")

#EXCEPTION HANDLING
except IndexError: sys.exit("\nIP-RANGE only supported in last octet .i.e 1.1.1.1-100\n")
except socket.gaierror: print("\nUnable to resolve hostname!\n")
except socket.error: print("\nCouldn't connect to the server!\n")
except KeyboardInterrupt:
	log.info("\nQuitting... Ctrl+C was pressed\n")
	write()
	sys.exit()
except getopt.GetoptError:
	if sys.argv[1] == "-p" or sys.argv[1] == "--port": sys.exit("\nOption -p requires an argument\n")
	elif sys.argv[1] == "-w" or sys.argv[1] == "--write": sys.exit("\nOption -w requires an argument\n")
	else: sys.exit("\nArgument Value Missing/Option Not Valid!\n")
else:
	write()

	
########## LIMITATIONS AS OF NOW ############

#UDP SCAN NOT WORKING PRESENTLY!!!!
#IS SLOW AS NO MULTI-THREADING CONCEPTS USED IN THE PROGRAM.
#THE USER MUST MAINTAIN A SEQUENCE "dedmap <options> <target>"
#THE TOOL SUPPORTS IP-RANGE ONLY IN THE LAST OCTET .i.e 1.1.1.(1-200)  --> This is also a safety measure to prevent the user from scanning the ENTIRE INTERNET (1-255.1-255.1-255.1-255) and blowing up his/her NIC, RAM, CPU and HARDDISK :p


########### TO DO #################
#FIX UDP SCANNING
#ADD COLORS TO THE REST OF THE OUTPUT TO PROVIDE EVEN BASED VISUAL RESPONSES.
#ADD SUPPORT FOR OS DETECTION IN OPTION
#USE MULTITHREADING TO DRASTICALLY IMPROVE THE PERFORMANCE OF THE TOOL
#TEST AND ADD SUPPORT FOR WINDOWS
#INCLUDE NMAP SCRIPTING ENGINE
#BEAT NMAP :p
