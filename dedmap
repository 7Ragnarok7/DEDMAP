#!/usr/bin/env python3

#IMPORTING REQUIRED LIBRARIES
from datetime import datetime
from time import time
from funcy import flatten
from numpy import array
from sys import argv
from colorama import init, Fore
from os import popen, path
from subprocess import call
import socket, getopt, logging as log

try:
	#SETTING UP A COLOR SCHEME FOR BETTER VISUALISATION
	init()
	BLUE = Fore.BLUE   			#FOR MARKING THE SUCCESSFUL STARTING AND COMPLETION OF THE PROGRAM
	RED = Fore.RED	   			#FOR MARKING STARTING/ENDING OF AN EVENT OR AN ERROR
	GREEN = Fore.GREEN 			#FOR MARKING A SUCCESSFUL HOST/PORT DISCOVERY AND HELP MENU
	RESET = Fore.RESET			#FOR RESETTING TO DEFAULT SHELL COLOR
	GRAY = Fore.LIGHTBLACK_EX	#FOR MARKING AN UNSUCCESSFUL HOST/PORT DISCOVERY IN VERBOSE MODE
	YELLOW = Fore.YELLOW		#FOR MARKING DEBUGGING STATEMENTS
	
	#SETTING UP A LOGGING SYSTEM
	log.basicConfig(level = log.INFO, format = '  %(message)s', handlers = [log.FileHandler('temp.log'), log.StreamHandler()])
	
	#CHECKING WHETHER DEDMAP IS INSTALLED OR NOT
	INSTALLED = path.exists('/usr/share/dedmap/') or path.exists('/data/data/com.termux/files/usr/share/dedmap/')
	
	#GRAPHICS/TEXT ART
	if INSTALLED: call('echo && pyfiglet -c RED dedmap -f Bloody', shell = True)
	else: call('echo && figlet -f fonts/Bloody.flf dedmap', shell = True)

	#INITIAL MESSAGE
	log.info(f'\n{BLUE}Starting DEDMAP at {datetime.now().strftime("%B %d, %Y %H:%M:%S")} ( https://7Ragnarok7.github.io/DEDMAP ) .....{RESET}')
	with open("temp.log", "a") as file: file.write(f'\nCommand used: {" ".join(argv)}\n')
	
	#FUNCTION TO SAVE THE OUTPUT TO A FILE
	def out():
		if "--out" in options: 
			print(f'\n{GREEN}Writing the output to {options["--out"]}{RESET}\n')
			call(f'cat temp.log >> {options["--out"]} && rm temp.log', shell = True)
		else: call("rm temp.log", shell = True)

	#DEFINED A HELP FUNCTION TO OUTPUT USAGE INSTRUCTIONS
	def help(): print(GREEN + """
DEDMAP ( https://7Ragnarok7.github.io/DEDMAP )

Usage: dedmap [--option(s)] [target(s)]

By default, a tcp scan will be performed if no options are provided.
-t option must be exclusively provided if any other option is used like -p or -v or -n.
By default, the top 1024 ports will be scanned if no ports are specified.
Long Options (--<options>) have more priority.

Options:
-h, --help              show this help message and exit
-v, --verbose           run in verbose mode
-d, --dns               performs a dns lookup
-r, --rdns              performs a reverse dns lookup
-p, --port<port(s)>     only scan specified port(s)
                        Ex: -p 21; -p 21,22,23;
                        -p user; (scan user ports from 1024 to 49151)
                        -p private; (scan private ports from 49152 to 65535)
                        -p all; (scan all ports from 0 to 65535)
-t, --tcp               perform a tcp scan (default scan if NO OPTIONS are specified)
-u, --udp               perform a udp scan (Dosen't seems to work using socket in python)
-n, --net             	perform a network scan
-m, --mode<wan/lan>     select the mode for network scan (default = wan)
                        Select lan mode(turbo mode) for better scanning speeds (upto 10x)
                        It is recommended to use the turbo mode only on a lan network
                        as it might result loss of accuracy in wan networks
                        Ex: -nm lan; -nm wan;
-o, --out<filename>   	save the output to a file
                        Ex: -o report.dedmap

Examples:               dedmap 1.1.1.1
                        dedmap localhost
                        dedmap -d google.com yahoo.com facebook.com localhost
                        dedmap google.com
                        dedmap google.com yahoo.com
                        dedmap 1.1.1.1 2.2.2.2 3.3.3.3
                        dedmap 1.1.1.1-100 google.com (Perform a tcp scan on all the hosts without pinging to bypass firewall icmp block)
                        dedmap -p 20 1.1.1.1
                        dedmap -p 20,21,22 1.1.1.1
                        dedmap -nm lan -p 21 192.168.1.1-255 (Perform a tcp port scan in lan mode on all the live hosts)
                        dedmap -n 1.1.1.1-255
                        dedmap -nr 1.1.1.1-255 (Perform a dns lookup on all the live targets in the network)
                        dedmap -nt 1.1.1.0-255 (To scan only the hosts which are alive in the network)
                        dedmap -o report.dedmap 127.0.0.1
""" + RESET)


	#DEFINED A FUNCTION FOR DEBUGGING
	def debug():
		print(YELLOW, targets, RESET)
		print(YELLOW, TARGET_LEN, RESET)
		print(YELLOW, options, RESET)
		print(YELLOW, OPTION_LEN, RESET)
		print(YELLOW, live_targets, RESET)
	
	
	#DESIGNED A FUNTION TO GIVE PRIORITY TO LONG-FORMAT ARGUMENTS
	def priority():
		for item in POSSIBLE_OPTIONS:
			if item in options and POSSIBLE_OPTIONS[item] in options: del(options[item])
			elif item in options: options[POSSIBLE_OPTIONS[item]] = options.pop(item)
		
	
	#DESIGNED AN ALGORITHM TO CONVERT IP-RANGE TO A LIST OF IP'S
	def convert(seperated, index):
		new_targets = []
		octets = seperated[0].split(".")
		new = [i for i in range(int(octets[3]), int(seperated[1]) + 1)]
		for i in new: new_targets.append(".".join([octets[0], octets[1], octets[2], str(i)]))	 
		targets[index] = new_targets
		
	
	#TCP/UDP SCANNER
	def scanner(ip, p, mode):
		global port_count
		if mode == "tcp": sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
		else: sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
		sock.settimeout(0.1)
		result = sock.connect_ex((ip, p))
		
		if not result:
			port_count += 1
			log.info(f"{GREEN}  PORT {p}  -->   OPEN   {RESET}")
		elif result and "--verbose" in options: print(f"{GRAY}  PORT {p}  -->   CLOSED   {RESET}")
		sock.close()	
	
	#TCP/UDP SCAN SELECTOR ***************
	def tcp_udp(mode, start, end):
		log.info(f"\n{RED}Performing a {mode} scan.....{RESET}\n")
		global port_count
		
		if "--net" in options:
			log.info(f"\n{GREEN}Found {len(live_targets)} live targets!\nScanning only the live hosts as a network scan was performed before.{RESET}")
			scan_targets = live_targets
		else:
			log.info(f"\n{RED}Scanning all {len(targets)} targets as no network scan was performed.{RESET}\n")
			scan_targets = targets.values()
			
		for ip in scan_targets:
			log.info(f"\n{RED}---------------- Scanning {SWAP_TARGETS[ip]} ({ip}) ---------------{RESET}\n")
			port_count = 0
		
			if len(ports): port_range = ports
			else: port_range = range(start, end)
				
			for p in port_range:
				if mode == "tcp" or mode == "udp": scanner(ip, p, mode)
				else:
					out()
					exit(f"\n{RED}Invalid scan option specified!{RESET}\n")
			if port_count: log.info(f"\n{GREEN}Found {port_count} out of {len(port_range)} ports open for the host: {SWAP_TARGETS[ip]}{RESET}\n")
	
	#MAIN SCAN CALLING FUNCTION ********
	def scan():
		
		#DNS LOOKUP
		if "--dns" in options: log.info(f"\n{RED}Performing a DNS lookup.....{RESET}\n\n{GREEN}{targets}{RESET}\n")
		
		#NETWORK SCAN
		if "--net" in options:
			log.info(f"\n{RED}Performing a network scan.....{RESET}\n")
			for ip in targets.values():
				if "--verbose" in options: print(f"{RED}Scanning {SWAP_TARGETS[ip]} .....{RESET}")
				if "--mode" not in options or options["--mode"] == "wan": response = popen(f"ping -b -c 1 -W 1 {ip}")
				elif options["--mode"] == "lan": response = popen(f"ping -b -c 1 -W 0.1 {ip}")
				else: exit(f"\n{RED}Invalid network scan mode specified!{RESET}\n")
				if "ttl" in response.readlines()[1].lower():
					log.info(f"{GREEN}{ip} --> Live{RESET}")
					live_targets.append(ip) #STORING ALL THE LIVE TARGETS
			log.info(f"\n{GREEN}{len(live_targets)} hosts alive out of {TARGET_LEN}{RESET}\n")
		
		
		#REVERSE-DNS LOOKUP
		if "--rdns" in options:
			log.info(f"\n{RED}Performing a REVERSE-DNS lookup.....{RESET}\n")
			if "--net" in options: hostnames = list(map(socket.gethostbyaddr, live_targets))
			else: hostnames = list(map(socket.gethostbyaddr, targets.values()))
			log.info(array(list(zip(hostnames, live_targets))))
			
		
		#TCP/UDP SCAN
		if "--tcp" in options or OPTION_LEN == 0: #MUST SPECIFY -t OPTION IN ANY OTHER OPTION IS GIVEN (EVEN -v)
			if "--port" not in options: tcp_udp("tcp", 0, 1024)
			elif options["--port"] == "user": tcp_udp("tcp", 1024, 49152)
			elif options["--port"] == "private": tcp_udp("tcp", 49152, 65536)
			elif options["--port"] == "all": tcp_udp("tcp", 0, 65536)
			elif len(ports) and "".join([str(i) for i in ports]).isdigit(): tcp_udp("tcp", 0, 0)
			else: print(f"{RED}\nInvalid port option specified!{RESET}\n")
			
		if "--udp" in options:
			if "--port" not in options: tcp_udp("udp", 0, 1024)
			elif options["--port"] == "user": tcp_udp("udp", 1024, 49152)
			elif options["--port"] == "private": tcp_udp("udp", 49152, 65536)
			elif options["--port"] == "all": tcp_udp("udp", 0, 65536)
			elif len(ports) and "".join([str(i) for i in ports]).isdigit(): tcp_udp("udp", 0, 0)
			else: print(f"\n{RED}Invalid port option specified!{RESET}\n")
			
		
	#GETTING HOSTNAMES, IPs AND SCANNING PARAMETERS FORM SHELL ARGUMENTS
	options, targets = getopt.getopt(argv[1:], 'ndrtuhvp:o:m:', ['net', 'dns', 'rdns', 'tcp', 'udp', 'help', 'verbose', 'port=', 'out=', 'mode='])
	

	#CHECKING WHETHER THERE IS AN IP-RANGE OR NOT 
	for item in targets:
		if "-" in item:
			new = item.split("-")
			if "".join(new[0].split(".")).isdigit(): convert(new, targets.index(item))

	
	#VARIABLES
	targets = list(flatten(targets)) #CONVERTING NESTED LISTS RETURNED FROM CONVERT() TO NORMAL LISTS
	targets = dict(zip(targets, list(map(socket.gethostbyname, targets)))) #CONVERTING THE TARGETS INTO A DICTIONARY WITH THEIR RESPECTIVE IPs FOR BETTER ADDRESSING
	options = dict(options) #CONVERTING THE OPTIONS INTO A DICTIONARY FOR BETTER ADDRESSING
	ports = []
	live_targets = []
	
	#CONSTANTS
	POSSIBLE_OPTIONS = {"-n":"--net", "-m":"--mode", "-d":"--dns", "-r":"--rdns", "-t":"--tcp", "-u":"--udp", "-h":"--help", "-v":"--verbose", "-p":"--port", "-o":"--out"}
	TARGET_LEN = len(targets)
	OPTION_LEN = len(options)
	SWAP_TARGETS = dict(zip(targets.values(), targets.keys())) #Same targets dictionary with keys and values swapped with each other
	
	#CHECKING FOR EMPTY HOSTS
	if not targets:
		out()
		exit(f"\n{RED}No targets specified!{RESET}\n\n{GREEN}Usage: dedmap [--option(s)] [target(s)]\n\n{array(list(zip(list(POSSIBLE_OPTIONS), list(POSSIBLE_OPTIONS.values()))))}\n\nUse dedmap -h or --help to get a detailed usage instruction.{RESET}\n")
	
	#GIVING PRIORITY TO LONG-FORMAT ARGUMENTS
	priority()
	
	
	#GETTING SPECIFIC PORTS
	if "--port" in options: 
		if "," in options["--port"] : ports = options["--port"].split(",")
		elif options["--port"].isdigit(): ports.append(options["--port"])
	ports = [int(i) for i in ports]

	
	################### MAIN ############################ *********

	#HELP
	if "--help" in options:
		out()
		exit(help())

	#RECORDING THE STARTING TIME TO CALCULATE TOTAL SCANNING TIME
	STARTING_TIME = time()
	
	#STARTING THE SCAN *********
	scan()
	
	#TOTAL COMPLETION TIME
	log.info(f"\n{BLUE}Scan completed in: {round(time() - STARTING_TIME, 2)} seconds.{RESET}")
	
	#DEBUGGING ---- COMMENT OR UNCOMMENT TO TURN OFF OR ON. MOVE THIS PART OF CODE ABOVE OR BELOW SOME OTHER CODE TO PERFORM EXECUTION ORDER-SPECIFIC DEBUGGING
	#debug()

	#REPORTING
	log.info(f"\n{YELLOW}Report BUGS at ( https://github.com/7Ragnarok7/DEDMAP/issues ){RESET}\n")


#EXCEPTION HANDLING
except IndexError: exit(f"\n{RED}IP-RANGE only supported in last octet .i.e 1.1.1.1-100{RESET}\n")
except socket.gaierror: print(f"\n{RED}Unable to resolve hostname!{RESET}\n")
except socket.error: print(f"\n{RED}Couldn't connect to the server!{RESET}\n")
except KeyboardInterrupt:
	log.info(f"\n{RED}Quitting... Ctrl+C was pressed{RESET}\n")
	exit(out())
except getopt.GetoptError:
	if argv[1] == "-p" or argv[1] == "--port": exit(f"\n{RED}Option -p requires an argument{RESET}\n")
	elif argv[1] == "-o" or argv[1] == "--out": exit(f"\n{RED}Option -o requires an argument{RESET}\n")
	else: exit(f"\n{RED}Argument Value Missing/Option Not Valid!{RESET}\n")
else: out()
